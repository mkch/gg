// This package is generated by Copilot based on my original instruction to "find function/methods
// in Go std library that return 2 values plus an error" and some more.
// The purpose is to help me write examples of errorcheck.Must2 usage.
package main

import (
	"bufio"
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strconv"
	"strings"
)

type FuncInfo struct {
	PkgPath   string
	Receiver  string // empty if function, otherwise receiver type
	Name      string
	Signature string
	File      string
}

func lastFieldIsError(fl *ast.FieldList) bool {
	if fl == nil || len(fl.List) == 0 {
		return false
	}
	last := fl.List[len(fl.List)-1]
	if id, ok := last.Type.(*ast.Ident); ok {
		return id.Name == "error"
	}
	return false
}

func resultValueCount(fl *ast.FieldList) int {
	if fl == nil {
		return 0
	}
	cnt := 0
	for _, f := range fl.List {
		if len(f.Names) == 0 {
			cnt += 1
		} else {
			cnt += len(f.Names)
		}
	}
	return cnt
}

// receiverTypeName returns a simplified receiver type name for display
func receiverTypeName(fd *ast.FieldList) string {
	if fd == nil || len(fd.List) == 0 {
		return ""
	}
	t := fd.List[0].Type
	if star, ok := t.(*ast.StarExpr); ok {
		t = star.X
	}
	switch x := t.(type) {
	case *ast.Ident:
		return x.Name
	case *ast.SelectorExpr:
		return x.Sel.Name
	}
	return ""
}

func isPublicImportPath(path string) bool {
	// public means not in any "internal" segment
	for _, seg := range strings.Split(path, "/") {
		if seg == "internal" {
			return false
		}
	}
	return true
}

func formatSignature(fset *token.FileSet, funcType *ast.FuncType) string {
	var buf bytes.Buffer
	cfg := printer.Config{Mode: printer.RawFormat}
	cfg.Fprint(&buf, fset, funcType)
	sig := buf.String()
	// Remove "func" prefix if present
	return strings.TrimPrefix(sig, "func")
}

func usage() {
	fmt.Fprintln(os.Stderr, `usage: list_n_val_error <n>
  List exported functions/methods from Go std library (excluding internal and vendor packages)
  that return n values plus an error (error as the last return value).
  For methods, both the receiver type and method name must be exported.`)
}

func main() {
	if len(os.Args) < 2 {
		usage()
		os.Exit(2)
	}
	n, err := strconv.Atoi(os.Args[1])
	if err != nil || n < 0 {
		fmt.Fprintf(os.Stderr, "invalid n: %v\n", os.Args[1])
		usage()
		os.Exit(2)
	}

	cmd := exec.Command("go", "list", "-f", "{{.ImportPath}}\t{{.Dir}}", "std")
	var out bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		fmt.Fprintf(os.Stderr, "failed to run 'go list std': %v\n", err)
		os.Exit(1)
	}

	type pkgEntry struct{ path, dir string }
	var pkgs []pkgEntry
	scanner := bufio.NewScanner(&out)
	for scanner.Scan() {
		line := scanner.Text()
		if strings.TrimSpace(line) == "" {
			continue
		}
		parts := strings.Split(line, "\t")
		if len(parts) != 2 {
			continue
		}
		pkgs = append(pkgs, pkgEntry{path: parts[0], dir: parts[1]})
	}
	if err := scanner.Err(); err != nil {
		fmt.Fprintf(os.Stderr, "scan error: %v\n", err)
		os.Exit(1)
	}

	fset := token.NewFileSet()
	var results []FuncInfo

	for _, p := range pkgs {
		if p.path == "unsafe" || !isPublicImportPath(p.path) || strings.HasPrefix(p.path, "vendor/") {
			continue
		}
		entries, err := os.ReadDir(p.dir)
		if err != nil {
			continue
		}
		for _, e := range entries {
			name := e.Name()
			if e.IsDir() {
				continue
			}
			if !strings.HasSuffix(name, ".go") || strings.HasSuffix(name, "_test.go") {
				continue
			}
			full := filepath.Join(p.dir, name)
			file, err := parser.ParseFile(fset, full, nil, 0)
			if err != nil {
				continue
			}
			for _, decl := range file.Decls {
				fd, ok := decl.(*ast.FuncDecl)
				if !ok || fd.Type == nil || fd.Type.Results == nil {
					continue
				}
				// exported function or method name
				if !ast.IsExported(fd.Name.Name) {
					continue
				}
				// Expect exactly n + 1 results and last is error
				if resultValueCount(fd.Type.Results) != n+1 {
					continue
				}
				if !lastFieldIsError(fd.Type.Results) {
					continue
				}
				recv := receiverTypeName(fd.Recv)
				// if method, require exported receiver type as well
				if fd.Recv != nil && !ast.IsExported(recv) {
					continue
				}
				sig := formatSignature(fset, fd.Type)
				results = append(results, FuncInfo{
					PkgPath:   p.path,
					Receiver:  recv,
					Name:      fd.Name.Name,
					Signature: sig,
					File:      full,
				})
			}
		}
	}

	sort.Slice(results, func(i, j int) bool {
		if results[i].PkgPath != results[j].PkgPath {
			return results[i].PkgPath < results[j].PkgPath
		}
		if results[i].Receiver != results[j].Receiver {
			return results[i].Receiver < results[j].Receiver
		}
		return results[i].Name < results[j].Name
	})

	for _, r := range results {
		if r.Receiver == "" {
			fmt.Printf("%s.%s%s\n", r.PkgPath, r.Name, r.Signature)
		} else {
			fmt.Printf("%s.(%s).%s%s\n", r.PkgPath, r.Receiver, r.Name, r.Signature)
		}
	}
}
