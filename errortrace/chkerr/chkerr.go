package chkerr

import (
	"testing"

	"github.com/mkch/gg/errorcheck"
	"github.com/mkch/gg/errortrace"
)

// Must calls [errorcheck.Must] with [errortrace.Panic] as the [errorcheck.Handler].
func Must[T any](v T, err error) T {
	return errorcheck.Must(errortrace.Panic, v, err)
}

// Must2 calls [errorcheck.Must2] with [errortrace.Panic] as the [errorcheck.Handler].
func Must2[T1, T2 any](v1 T1, v2 T2, err error) (T1, T2) {
	return errorcheck.Must2(errortrace.Panic, v1, v2, err)
}

// Must3 calls [errorcheck.Must3] with [errortrace.Panic] as the [errorcheck.Handler].
func Must3[T1, T2, T3 any](v1 T1, v2 T2, v3 T3, err error) (T1, T2, T3) {
	return errorcheck.Must3(errortrace.Panic, v1, v2, v3, err)
}

// Must4 calls [errorcheck.Must4] with [errortrace.Panic] as the [errorcheck.Handler].
func Must4[T1, T2, T3, T4 any](v1 T1, v2 T2, v3 T3, v4 T4, err error) (T1, T2, T3, T4) {
	return errorcheck.Must4(errortrace.Panic, v1, v2, v3, v4, err)
}

// checkErr is a helper function that checks the error and calls t.Fatal if it's not nil.
func checkErr(t *testing.T, message string, err error) {
	t.Helper()
	if err != nil {
		t.Fatal(message+":", errortrace.Sprint(err))
		// t.Fatal calls runtime.GoExit.
		// Never returns
	}
}

// test is a helper type for Test function.
type test[T any] struct {
	v   T
	err error
}

func (c test[T]) Must(t *testing.T, message string) T {
	t.Helper()
	checkErr(t, message, c.err)
	return c.v
}

// Test returns an object that has a
//
//	Must(t *testing.T, message string) T
//
// method. This method returns v if err is nil, or calls t.Fatal with the given message
// and the error trace generated by [errortrace.Sprintf(err)] if err is not nil.
func Test[T any](v T, err error) test[T] {
	return test[T]{v: v, err: err}
}

// test2 is a helper type for Test2 function.
type test2[T1, T2 any] struct {
	v1  T1
	v2  T2
	err error
}

func (c test2[T1, T2]) Must(t *testing.T, message string) (T1, T2) {
	t.Helper()
	checkErr(t, message, c.err)
	return c.v1, c.v2
}

// Test2 is like [Test] but for two return values.
// Test2 returns an object that has a
//
//	Must(t *testing.T, message string) (T1, T2)
//
// method. This method returns v1 and v2 if err is nil, or calls t.Fatal with the given message
// and the error trace generated by [errortrace.Sprintf(err)] if err is not nil.
func Test2[T1, T2 any](v1 T1, v2 T2, err error) test2[T1, T2] {
	return test2[T1, T2]{v1: v1, v2: v2, err: err}
}
